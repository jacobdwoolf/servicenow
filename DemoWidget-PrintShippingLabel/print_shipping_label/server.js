(function () {
    /* populate the 'data' object */
    /* e.g., data.table = $sp.getValue('table'); */

    // read the parameters from the URL, using 'false' as the default value if a particular paremeter doesn't exist
    var params = {
        'table': $sp.getParameter('table') || false,
        'sysId': $sp.getParameter('sys_id') || false,
        'query': $sp.getParameter('query') || false
    }

    /**
     * read in and adjust/manipulate the options values as needed
     * 
     * the page_header line here is skipped, since the value isn't being manipulated, and the 'options' object is available to the template directly
     * if you wanted to adjust/manipulate this value, or use other details generated by the script, you can either override options.variable_name, or parse it into its own property on the data object
     * 'options.highlight_vip' is overridden here, as it will natively be read as a string (even though option type is boolean), so override the value with an actual boolean for ease of use later
     */

    // data.pageHeader = options.page_header;
    options.highlight_vip = (options.highlight_vip == 'true') ? true : false;


    /**
     * "main" function: grab the GlideRecord using the parameters, and parse the necessary values onto the data object
     */
    var gr = getGlideRecord(params.table, params.sysId, params.query);
    if (!gr)
        data.recordData = false;
    else
        data.recordData = buildRecordData(gr);


    /**
     * helper/utility functions, broken out for modularity/reusability - these could just as easily come from an OOB or custom script include
     * 
     * one thing to keep in mind here is "graceful failure", as pretty much any runtime JS error here will cause the entire page to no-load and throw a bunch of red error messages
     *  error handling can be done by whatever method is preferred (returning false/null values, try/catch, etc) so long as the script ultimately returns
     *  and the client script/template do their own checking and don't try to access undefined values/variables on the data or options object
     *  for example, the "getGlideRecord" function checks the existence/validity of each input before each step, to prevent GlideRecord from throwing uncaught errors
     */
    function buildRecordData(gr) {
        var grData = [];

        if (gr.getRowCount() == 1 && gr.isValidRecord()) {
            grData.push(parseTaskGr(gr));
        }

        if (gr.getRowCount() > 1) {
            while (gr.next()) {
                grData.push(parseTaskGr(gr));
            }
        }

        return grData;
    }

    /**
     * parse the values from a single GlideRecord, and return as a JSON object
     */
    function parseTaskGr(singleRecord) {
        var parsedData = {
            'number': singleRecord.getValue('number'),
            'shortDesc': singleRecord.getValue('short_description'),
            'reqFor': getUserData(singleRecord.getValue('requested_for'))
        };

        var watchlist = singleRecord.getValue('watch_list');

        if (watchlist && watchlist.length > 0)
            parsedData.watchlist = watchlist.split(',').map(getUserData);

        return parsedData;
    }

    /**
     * since dotwalking references can be unreliable (and isn't always an option, ie for watchlist), specific function for getting referenced user details
     * 
     * note usage of the widget option for enabling/disabling the addition of the highlight class to VIP users
     * this could also be applied on the template, but doing so here simplifies the condition string embedded in the ng-class attribute
     */
    function getUserData(userSysId) {
        var userGr = new GlideRecord('sys_user');
        userGr.get(userSysId);

        if (!userGr.isValidRecord())
            return false;

        return {
            'name': userGr.getValue('name'),
            'email': userGr.getValue('email'),
            'phone': userGr.getValue('phone'),
            'vip': (options.highlight_vip && userGr.getValue('vip') == true) ? true : false
        }
    }

    /**
     * given a table name and sysId or encodedQuery, validate and run a GlideRecord query, then validate and return the result
     * if any paramter or result is invalid, 'false' is returned; by checking for falsy values up the stack, we can easily avoid any cascading errors
     * depending on use case, it may be desired to log these errors to either gslog or console, we just want to avoid unhandled errors throwing red info messages and causing the page load to fail
     */
    function getGlideRecord(table, sysId, query) {
        if (!table)
            return false;

        var gr = new GlideRecord(table);

        if (!gr.isValid())
            return false;

        if (sysId) {
            gr.get(sysId);

            if (gr.isValidRecord())
                return gr;

            return false;
        }

        if (query) {
            if (!gr.isEncodedQueryValid(query))
                return false;

            gr.addEncodedQuery(query);
            gr.query();

            if (gr.getRowCount() > 0)
                return gr;

            return false;
        }

        return false;
    }
})();